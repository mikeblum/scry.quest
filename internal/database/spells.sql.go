// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: spells.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/pgvector/pgvector-go"
)

const createSpell = `-- name: CreateSpell :one
INSERT INTO scry_quest.spells (name, description, level, school, casting_time, range_value, components, duration, classes, embedding, raw_data)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING id, name, description, level, school, casting_time, range_value, components, duration, classes, embedding, raw_data, created_at, updated_at
`

type CreateSpellParams struct {
	Name        string          `json:"name"`
	Description pgtype.Text     `json:"description"`
	Level       int32           `json:"level"`
	School      pgtype.Text     `json:"school"`
	CastingTime pgtype.Text     `json:"casting_time"`
	RangeValue  pgtype.Text     `json:"range_value"`
	Components  pgtype.Text     `json:"components"`
	Duration    pgtype.Text     `json:"duration"`
	Classes     []string        `json:"classes"`
	Embedding   pgvector.Vector `json:"embedding"`
	RawData     []byte          `json:"raw_data"`
}

func (q *Queries) CreateSpell(ctx context.Context, arg CreateSpellParams) (ScryQuestSpell, error) {
	row := q.db.QueryRow(ctx, createSpell,
		arg.Name,
		arg.Description,
		arg.Level,
		arg.School,
		arg.CastingTime,
		arg.RangeValue,
		arg.Components,
		arg.Duration,
		arg.Classes,
		arg.Embedding,
		arg.RawData,
	)
	var i ScryQuestSpell
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Level,
		&i.School,
		&i.CastingTime,
		&i.RangeValue,
		&i.Components,
		&i.Duration,
		&i.Classes,
		&i.Embedding,
		&i.RawData,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteSpell = `-- name: DeleteSpell :exec
DELETE FROM scry_quest.spells WHERE id = $1
`

func (q *Queries) DeleteSpell(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteSpell, id)
	return err
}

const getSpellByID = `-- name: GetSpellByID :one
SELECT id, name, description, level, school, casting_time, range_value, components, duration, classes, embedding, raw_data, created_at, updated_at FROM scry_quest.spells WHERE id = $1
`

func (q *Queries) GetSpellByID(ctx context.Context, id pgtype.UUID) (ScryQuestSpell, error) {
	row := q.db.QueryRow(ctx, getSpellByID, id)
	var i ScryQuestSpell
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Level,
		&i.School,
		&i.CastingTime,
		&i.RangeValue,
		&i.Components,
		&i.Duration,
		&i.Classes,
		&i.Embedding,
		&i.RawData,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSpellByName = `-- name: GetSpellByName :one
SELECT id, name, description, level, school, casting_time, range_value, components, duration, classes, embedding, raw_data, created_at, updated_at FROM scry_quest.spells WHERE name = $1
`

func (q *Queries) GetSpellByName(ctx context.Context, name string) (ScryQuestSpell, error) {
	row := q.db.QueryRow(ctx, getSpellByName, name)
	var i ScryQuestSpell
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Level,
		&i.School,
		&i.CastingTime,
		&i.RangeValue,
		&i.Components,
		&i.Duration,
		&i.Classes,
		&i.Embedding,
		&i.RawData,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listSpells = `-- name: ListSpells :many
SELECT id, name, description, level, school, casting_time, range_value, components, duration, classes, embedding, raw_data, created_at, updated_at FROM scry_quest.spells
ORDER BY name
LIMIT $1 OFFSET $2
`

type ListSpellsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListSpells(ctx context.Context, arg ListSpellsParams) ([]ScryQuestSpell, error) {
	rows, err := q.db.Query(ctx, listSpells, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ScryQuestSpell{}
	for rows.Next() {
		var i ScryQuestSpell
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Level,
			&i.School,
			&i.CastingTime,
			&i.RangeValue,
			&i.Components,
			&i.Duration,
			&i.Classes,
			&i.Embedding,
			&i.RawData,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSpellsByLevel = `-- name: ListSpellsByLevel :many
SELECT id, name, description, level, school, casting_time, range_value, components, duration, classes, embedding, raw_data, created_at, updated_at FROM scry_quest.spells
WHERE level = $1
ORDER BY name
`

func (q *Queries) ListSpellsByLevel(ctx context.Context, level int32) ([]ScryQuestSpell, error) {
	rows, err := q.db.Query(ctx, listSpellsByLevel, level)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ScryQuestSpell{}
	for rows.Next() {
		var i ScryQuestSpell
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Level,
			&i.School,
			&i.CastingTime,
			&i.RangeValue,
			&i.Components,
			&i.Duration,
			&i.Classes,
			&i.Embedding,
			&i.RawData,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSpellsBySchool = `-- name: ListSpellsBySchool :many
SELECT id, name, description, level, school, casting_time, range_value, components, duration, classes, embedding, raw_data, created_at, updated_at FROM scry_quest.spells
WHERE school = $1
ORDER BY name
`

func (q *Queries) ListSpellsBySchool(ctx context.Context, school pgtype.Text) ([]ScryQuestSpell, error) {
	rows, err := q.db.Query(ctx, listSpellsBySchool, school)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ScryQuestSpell{}
	for rows.Next() {
		var i ScryQuestSpell
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Level,
			&i.School,
			&i.CastingTime,
			&i.RangeValue,
			&i.Components,
			&i.Duration,
			&i.Classes,
			&i.Embedding,
			&i.RawData,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchSpellsByEmbedding = `-- name: SearchSpellsByEmbedding :many
SELECT id, name, description, level, school, casting_time, range_value, components, duration, classes, embedding, raw_data, created_at, updated_at, (embedding <=> $1::vector) as distance
FROM scry_quest.spells
ORDER BY embedding <=> $1::vector
LIMIT $2
`

type SearchSpellsByEmbeddingParams struct {
	Column1 pgvector.Vector `json:"column_1"`
	Limit   int32           `json:"limit"`
}

type SearchSpellsByEmbeddingRow struct {
	ID          pgtype.UUID        `json:"id"`
	Name        string             `json:"name"`
	Description pgtype.Text        `json:"description"`
	Level       int32              `json:"level"`
	School      pgtype.Text        `json:"school"`
	CastingTime pgtype.Text        `json:"casting_time"`
	RangeValue  pgtype.Text        `json:"range_value"`
	Components  pgtype.Text        `json:"components"`
	Duration    pgtype.Text        `json:"duration"`
	Classes     []string           `json:"classes"`
	Embedding   pgvector.Vector    `json:"embedding"`
	RawData     []byte             `json:"raw_data"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	Distance    interface{}        `json:"distance"`
}

func (q *Queries) SearchSpellsByEmbedding(ctx context.Context, arg SearchSpellsByEmbeddingParams) ([]SearchSpellsByEmbeddingRow, error) {
	rows, err := q.db.Query(ctx, searchSpellsByEmbedding, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchSpellsByEmbeddingRow{}
	for rows.Next() {
		var i SearchSpellsByEmbeddingRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Level,
			&i.School,
			&i.CastingTime,
			&i.RangeValue,
			&i.Components,
			&i.Duration,
			&i.Classes,
			&i.Embedding,
			&i.RawData,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Distance,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSpellEmbedding = `-- name: UpdateSpellEmbedding :exec
UPDATE scry_quest.spells 
SET embedding = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateSpellEmbeddingParams struct {
	ID        pgtype.UUID     `json:"id"`
	Embedding pgvector.Vector `json:"embedding"`
}

func (q *Queries) UpdateSpellEmbedding(ctx context.Context, arg UpdateSpellEmbeddingParams) error {
	_, err := q.db.Exec(ctx, updateSpellEmbedding, arg.ID, arg.Embedding)
	return err
}
