// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: species.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/pgvector/pgvector-go"
)

const createSpecies = `-- name: CreateSpecies :one
INSERT INTO scry_quest.species (name, description, size, speed, ability_score_increase, traits, embedding, raw_data)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, name, description, size, speed, ability_score_increase, traits, embedding, raw_data, created_at, updated_at
`

type CreateSpeciesParams struct {
	Name                 string          `json:"name"`
	Description          pgtype.Text     `json:"description"`
	Size                 pgtype.Text     `json:"size"`
	Speed                pgtype.Int4     `json:"speed"`
	AbilityScoreIncrease []byte          `json:"ability_score_increase"`
	Traits               []string        `json:"traits"`
	Embedding            pgvector.Vector `json:"embedding"`
	RawData              []byte          `json:"raw_data"`
}

func (q *Queries) CreateSpecies(ctx context.Context, arg CreateSpeciesParams) (ScryQuestSpecy, error) {
	row := q.db.QueryRow(ctx, createSpecies,
		arg.Name,
		arg.Description,
		arg.Size,
		arg.Speed,
		arg.AbilityScoreIncrease,
		arg.Traits,
		arg.Embedding,
		arg.RawData,
	)
	var i ScryQuestSpecy
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Size,
		&i.Speed,
		&i.AbilityScoreIncrease,
		&i.Traits,
		&i.Embedding,
		&i.RawData,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteSpecies = `-- name: DeleteSpecies :exec
DELETE FROM scry_quest.species WHERE id = $1
`

func (q *Queries) DeleteSpecies(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteSpecies, id)
	return err
}

const getSpeciesByID = `-- name: GetSpeciesByID :one
SELECT id, name, description, size, speed, ability_score_increase, traits, embedding, raw_data, created_at, updated_at FROM scry_quest.species WHERE id = $1
`

func (q *Queries) GetSpeciesByID(ctx context.Context, id pgtype.UUID) (ScryQuestSpecy, error) {
	row := q.db.QueryRow(ctx, getSpeciesByID, id)
	var i ScryQuestSpecy
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Size,
		&i.Speed,
		&i.AbilityScoreIncrease,
		&i.Traits,
		&i.Embedding,
		&i.RawData,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSpeciesByName = `-- name: GetSpeciesByName :one
SELECT id, name, description, size, speed, ability_score_increase, traits, embedding, raw_data, created_at, updated_at FROM scry_quest.species WHERE name = $1
`

func (q *Queries) GetSpeciesByName(ctx context.Context, name string) (ScryQuestSpecy, error) {
	row := q.db.QueryRow(ctx, getSpeciesByName, name)
	var i ScryQuestSpecy
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Size,
		&i.Speed,
		&i.AbilityScoreIncrease,
		&i.Traits,
		&i.Embedding,
		&i.RawData,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listSpecies = `-- name: ListSpecies :many
SELECT id, name, description, size, speed, ability_score_increase, traits, embedding, raw_data, created_at, updated_at FROM scry_quest.species
ORDER BY name
LIMIT $1 OFFSET $2
`

type ListSpeciesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListSpecies(ctx context.Context, arg ListSpeciesParams) ([]ScryQuestSpecy, error) {
	rows, err := q.db.Query(ctx, listSpecies, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ScryQuestSpecy{}
	for rows.Next() {
		var i ScryQuestSpecy
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Size,
			&i.Speed,
			&i.AbilityScoreIncrease,
			&i.Traits,
			&i.Embedding,
			&i.RawData,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchSpeciesByEmbedding = `-- name: SearchSpeciesByEmbedding :many
SELECT id, name, description, size, speed, ability_score_increase, traits, embedding, raw_data, created_at, updated_at, (embedding <=> $1::vector) as distance
FROM scry_quest.species
ORDER BY embedding <=> $1::vector
LIMIT $2
`

type SearchSpeciesByEmbeddingParams struct {
	Column1 pgvector.Vector `json:"column_1"`
	Limit   int32           `json:"limit"`
}

type SearchSpeciesByEmbeddingRow struct {
	ID                   pgtype.UUID        `json:"id"`
	Name                 string             `json:"name"`
	Description          pgtype.Text        `json:"description"`
	Size                 pgtype.Text        `json:"size"`
	Speed                pgtype.Int4        `json:"speed"`
	AbilityScoreIncrease []byte             `json:"ability_score_increase"`
	Traits               []string           `json:"traits"`
	Embedding            pgvector.Vector    `json:"embedding"`
	RawData              []byte             `json:"raw_data"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	Distance             interface{}        `json:"distance"`
}

func (q *Queries) SearchSpeciesByEmbedding(ctx context.Context, arg SearchSpeciesByEmbeddingParams) ([]SearchSpeciesByEmbeddingRow, error) {
	rows, err := q.db.Query(ctx, searchSpeciesByEmbedding, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchSpeciesByEmbeddingRow{}
	for rows.Next() {
		var i SearchSpeciesByEmbeddingRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Size,
			&i.Speed,
			&i.AbilityScoreIncrease,
			&i.Traits,
			&i.Embedding,
			&i.RawData,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Distance,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSpeciesEmbedding = `-- name: UpdateSpeciesEmbedding :exec
UPDATE scry_quest.species 
SET embedding = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateSpeciesEmbeddingParams struct {
	ID        pgtype.UUID     `json:"id"`
	Embedding pgvector.Vector `json:"embedding"`
}

func (q *Queries) UpdateSpeciesEmbedding(ctx context.Context, arg UpdateSpeciesEmbeddingParams) error {
	_, err := q.db.Exec(ctx, updateSpeciesEmbedding, arg.ID, arg.Embedding)
	return err
}
