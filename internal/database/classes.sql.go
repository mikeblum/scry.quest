// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: classes.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/pgvector/pgvector-go"
)

const createClass = `-- name: CreateClass :one
INSERT INTO scry_quest.classes (name, description, hit_die, primary_ability, saving_throw_proficiencies, skill_proficiencies, embedding, raw_data)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, name, description, hit_die, primary_ability, saving_throw_proficiencies, skill_proficiencies, embedding, raw_data, created_at, updated_at
`

type CreateClassParams struct {
	Name                     string          `json:"name"`
	Description              pgtype.Text     `json:"description"`
	HitDie                   pgtype.Int4     `json:"hit_die"`
	PrimaryAbility           pgtype.Text     `json:"primary_ability"`
	SavingThrowProficiencies pgtype.Text     `json:"saving_throw_proficiencies"`
	SkillProficiencies       []string        `json:"skill_proficiencies"`
	Embedding                pgvector.Vector `json:"embedding"`
	RawData                  []byte          `json:"raw_data"`
}

func (q *Queries) CreateClass(ctx context.Context, arg CreateClassParams) (ScryQuestClass, error) {
	row := q.db.QueryRow(ctx, createClass,
		arg.Name,
		arg.Description,
		arg.HitDie,
		arg.PrimaryAbility,
		arg.SavingThrowProficiencies,
		arg.SkillProficiencies,
		arg.Embedding,
		arg.RawData,
	)
	var i ScryQuestClass
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.HitDie,
		&i.PrimaryAbility,
		&i.SavingThrowProficiencies,
		&i.SkillProficiencies,
		&i.Embedding,
		&i.RawData,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteClass = `-- name: DeleteClass :exec
DELETE FROM scry_quest.classes WHERE id = $1
`

func (q *Queries) DeleteClass(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteClass, id)
	return err
}

const getClassByID = `-- name: GetClassByID :one
SELECT id, name, description, hit_die, primary_ability, saving_throw_proficiencies, skill_proficiencies, embedding, raw_data, created_at, updated_at FROM scry_quest.classes WHERE id = $1
`

func (q *Queries) GetClassByID(ctx context.Context, id pgtype.UUID) (ScryQuestClass, error) {
	row := q.db.QueryRow(ctx, getClassByID, id)
	var i ScryQuestClass
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.HitDie,
		&i.PrimaryAbility,
		&i.SavingThrowProficiencies,
		&i.SkillProficiencies,
		&i.Embedding,
		&i.RawData,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getClassByName = `-- name: GetClassByName :one
SELECT id, name, description, hit_die, primary_ability, saving_throw_proficiencies, skill_proficiencies, embedding, raw_data, created_at, updated_at FROM scry_quest.classes WHERE name = $1
`

func (q *Queries) GetClassByName(ctx context.Context, name string) (ScryQuestClass, error) {
	row := q.db.QueryRow(ctx, getClassByName, name)
	var i ScryQuestClass
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.HitDie,
		&i.PrimaryAbility,
		&i.SavingThrowProficiencies,
		&i.SkillProficiencies,
		&i.Embedding,
		&i.RawData,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listClasses = `-- name: ListClasses :many
SELECT id, name, description, hit_die, primary_ability, saving_throw_proficiencies, skill_proficiencies, embedding, raw_data, created_at, updated_at FROM scry_quest.classes
ORDER BY name
LIMIT $1 OFFSET $2
`

type ListClassesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListClasses(ctx context.Context, arg ListClassesParams) ([]ScryQuestClass, error) {
	rows, err := q.db.Query(ctx, listClasses, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ScryQuestClass{}
	for rows.Next() {
		var i ScryQuestClass
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.HitDie,
			&i.PrimaryAbility,
			&i.SavingThrowProficiencies,
			&i.SkillProficiencies,
			&i.Embedding,
			&i.RawData,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchClassesByEmbedding = `-- name: SearchClassesByEmbedding :many
SELECT id, name, description, hit_die, primary_ability, saving_throw_proficiencies, skill_proficiencies, embedding, raw_data, created_at, updated_at, (embedding <=> $1::vector) as distance
FROM scry_quest.classes
ORDER BY embedding <=> $1::vector
LIMIT $2
`

type SearchClassesByEmbeddingParams struct {
	Column1 pgvector.Vector `json:"column_1"`
	Limit   int32           `json:"limit"`
}

type SearchClassesByEmbeddingRow struct {
	ID                       pgtype.UUID        `json:"id"`
	Name                     string             `json:"name"`
	Description              pgtype.Text        `json:"description"`
	HitDie                   pgtype.Int4        `json:"hit_die"`
	PrimaryAbility           pgtype.Text        `json:"primary_ability"`
	SavingThrowProficiencies pgtype.Text        `json:"saving_throw_proficiencies"`
	SkillProficiencies       []string           `json:"skill_proficiencies"`
	Embedding                pgvector.Vector    `json:"embedding"`
	RawData                  []byte             `json:"raw_data"`
	CreatedAt                pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                pgtype.Timestamptz `json:"updated_at"`
	Distance                 interface{}        `json:"distance"`
}

func (q *Queries) SearchClassesByEmbedding(ctx context.Context, arg SearchClassesByEmbeddingParams) ([]SearchClassesByEmbeddingRow, error) {
	rows, err := q.db.Query(ctx, searchClassesByEmbedding, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchClassesByEmbeddingRow{}
	for rows.Next() {
		var i SearchClassesByEmbeddingRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.HitDie,
			&i.PrimaryAbility,
			&i.SavingThrowProficiencies,
			&i.SkillProficiencies,
			&i.Embedding,
			&i.RawData,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Distance,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateClassEmbedding = `-- name: UpdateClassEmbedding :exec
UPDATE scry_quest.classes 
SET embedding = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateClassEmbeddingParams struct {
	ID        pgtype.UUID     `json:"id"`
	Embedding pgvector.Vector `json:"embedding"`
}

func (q *Queries) UpdateClassEmbedding(ctx context.Context, arg UpdateClassEmbeddingParams) error {
	_, err := q.db.Exec(ctx, updateClassEmbedding, arg.ID, arg.Embedding)
	return err
}
