// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: creatures.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/pgvector/pgvector-go"
)

const createBeast = `-- name: CreateBeast :one
INSERT INTO scry_quest.bestiary (name, size, type, subtype, alignment, armor_class, hit_points, hit_dice, speed, abilities, skills, senses, languages, challenge_rating, embedding, raw_data)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
RETURNING id, name, size, type, subtype, alignment, armor_class, hit_points, hit_dice, speed, abilities, skills, senses, languages, challenge_rating, embedding, raw_data, created_at, updated_at
`

type CreateBeastParams struct {
	Name            string          `json:"name"`
	Size            pgtype.Text     `json:"size"`
	Type            pgtype.Text     `json:"type"`
	Subtype         pgtype.Text     `json:"subtype"`
	Alignment       pgtype.Text     `json:"alignment"`
	ArmorClass      pgtype.Int4     `json:"armor_class"`
	HitPoints       pgtype.Int4     `json:"hit_points"`
	HitDice         pgtype.Text     `json:"hit_dice"`
	Speed           []byte          `json:"speed"`
	Abilities       []byte          `json:"abilities"`
	Skills          []byte          `json:"skills"`
	Senses          pgtype.Text     `json:"senses"`
	Languages       pgtype.Text     `json:"languages"`
	ChallengeRating pgtype.Text     `json:"challenge_rating"`
	Embedding       pgvector.Vector `json:"embedding"`
	RawData         []byte          `json:"raw_data"`
}

func (q *Queries) CreateBeast(ctx context.Context, arg CreateBeastParams) (ScryQuestBestiary, error) {
	row := q.db.QueryRow(ctx, createBeast,
		arg.Name,
		arg.Size,
		arg.Type,
		arg.Subtype,
		arg.Alignment,
		arg.ArmorClass,
		arg.HitPoints,
		arg.HitDice,
		arg.Speed,
		arg.Abilities,
		arg.Skills,
		arg.Senses,
		arg.Languages,
		arg.ChallengeRating,
		arg.Embedding,
		arg.RawData,
	)
	var i ScryQuestBestiary
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Size,
		&i.Type,
		&i.Subtype,
		&i.Alignment,
		&i.ArmorClass,
		&i.HitPoints,
		&i.HitDice,
		&i.Speed,
		&i.Abilities,
		&i.Skills,
		&i.Senses,
		&i.Languages,
		&i.ChallengeRating,
		&i.Embedding,
		&i.RawData,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteBeast = `-- name: DeleteBeast :exec
DELETE FROM scry_quest.bestiary WHERE id = $1
`

func (q *Queries) DeleteBeast(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteBeast, id)
	return err
}

const getBeastByID = `-- name: GetBeastByID :one
SELECT id, name, size, type, subtype, alignment, armor_class, hit_points, hit_dice, speed, abilities, skills, senses, languages, challenge_rating, embedding, raw_data, created_at, updated_at FROM scry_quest.bestiary WHERE id = $1
`

func (q *Queries) GetBeastByID(ctx context.Context, id pgtype.UUID) (ScryQuestBestiary, error) {
	row := q.db.QueryRow(ctx, getBeastByID, id)
	var i ScryQuestBestiary
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Size,
		&i.Type,
		&i.Subtype,
		&i.Alignment,
		&i.ArmorClass,
		&i.HitPoints,
		&i.HitDice,
		&i.Speed,
		&i.Abilities,
		&i.Skills,
		&i.Senses,
		&i.Languages,
		&i.ChallengeRating,
		&i.Embedding,
		&i.RawData,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBeastByName = `-- name: GetBeastByName :one
SELECT id, name, size, type, subtype, alignment, armor_class, hit_points, hit_dice, speed, abilities, skills, senses, languages, challenge_rating, embedding, raw_data, created_at, updated_at FROM scry_quest.bestiary WHERE name = $1
`

func (q *Queries) GetBeastByName(ctx context.Context, name string) (ScryQuestBestiary, error) {
	row := q.db.QueryRow(ctx, getBeastByName, name)
	var i ScryQuestBestiary
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Size,
		&i.Type,
		&i.Subtype,
		&i.Alignment,
		&i.ArmorClass,
		&i.HitPoints,
		&i.HitDice,
		&i.Speed,
		&i.Abilities,
		&i.Skills,
		&i.Senses,
		&i.Languages,
		&i.ChallengeRating,
		&i.Embedding,
		&i.RawData,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listBeasts = `-- name: ListBeasts :many
SELECT id, name, size, type, subtype, alignment, armor_class, hit_points, hit_dice, speed, abilities, skills, senses, languages, challenge_rating, embedding, raw_data, created_at, updated_at FROM scry_quest.bestiary
ORDER BY name
LIMIT $1 OFFSET $2
`

type ListBeastsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListBeasts(ctx context.Context, arg ListBeastsParams) ([]ScryQuestBestiary, error) {
	rows, err := q.db.Query(ctx, listBeasts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ScryQuestBestiary{}
	for rows.Next() {
		var i ScryQuestBestiary
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Size,
			&i.Type,
			&i.Subtype,
			&i.Alignment,
			&i.ArmorClass,
			&i.HitPoints,
			&i.HitDice,
			&i.Speed,
			&i.Abilities,
			&i.Skills,
			&i.Senses,
			&i.Languages,
			&i.ChallengeRating,
			&i.Embedding,
			&i.RawData,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBeastsByChallengeRating = `-- name: ListBeastsByChallengeRating :many
SELECT id, name, size, type, subtype, alignment, armor_class, hit_points, hit_dice, speed, abilities, skills, senses, languages, challenge_rating, embedding, raw_data, created_at, updated_at FROM scry_quest.bestiary
WHERE challenge_rating = $1
ORDER BY name
`

func (q *Queries) ListBeastsByChallengeRating(ctx context.Context, challengeRating pgtype.Text) ([]ScryQuestBestiary, error) {
	rows, err := q.db.Query(ctx, listBeastsByChallengeRating, challengeRating)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ScryQuestBestiary{}
	for rows.Next() {
		var i ScryQuestBestiary
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Size,
			&i.Type,
			&i.Subtype,
			&i.Alignment,
			&i.ArmorClass,
			&i.HitPoints,
			&i.HitDice,
			&i.Speed,
			&i.Abilities,
			&i.Skills,
			&i.Senses,
			&i.Languages,
			&i.ChallengeRating,
			&i.Embedding,
			&i.RawData,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBeastsByType = `-- name: ListBeastsByType :many
SELECT id, name, size, type, subtype, alignment, armor_class, hit_points, hit_dice, speed, abilities, skills, senses, languages, challenge_rating, embedding, raw_data, created_at, updated_at FROM scry_quest.bestiary
WHERE type = $1
ORDER BY name
`

func (q *Queries) ListBeastsByType(ctx context.Context, type_ pgtype.Text) ([]ScryQuestBestiary, error) {
	rows, err := q.db.Query(ctx, listBeastsByType, type_)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ScryQuestBestiary{}
	for rows.Next() {
		var i ScryQuestBestiary
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Size,
			&i.Type,
			&i.Subtype,
			&i.Alignment,
			&i.ArmorClass,
			&i.HitPoints,
			&i.HitDice,
			&i.Speed,
			&i.Abilities,
			&i.Skills,
			&i.Senses,
			&i.Languages,
			&i.ChallengeRating,
			&i.Embedding,
			&i.RawData,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchBeastsByEmbedding = `-- name: SearchBeastsByEmbedding :many
SELECT id, name, size, type, subtype, alignment, armor_class, hit_points, hit_dice, speed, abilities, skills, senses, languages, challenge_rating, embedding, raw_data, created_at, updated_at, (embedding <=> $1::vector) as distance
FROM scry_quest.bestiary
ORDER BY embedding <=> $1::vector
LIMIT $2
`

type SearchBeastsByEmbeddingParams struct {
	Column1 pgvector.Vector `json:"column_1"`
	Limit   int32           `json:"limit"`
}

type SearchBeastsByEmbeddingRow struct {
	ID              pgtype.UUID        `json:"id"`
	Name            string             `json:"name"`
	Size            pgtype.Text        `json:"size"`
	Type            pgtype.Text        `json:"type"`
	Subtype         pgtype.Text        `json:"subtype"`
	Alignment       pgtype.Text        `json:"alignment"`
	ArmorClass      pgtype.Int4        `json:"armor_class"`
	HitPoints       pgtype.Int4        `json:"hit_points"`
	HitDice         pgtype.Text        `json:"hit_dice"`
	Speed           []byte             `json:"speed"`
	Abilities       []byte             `json:"abilities"`
	Skills          []byte             `json:"skills"`
	Senses          pgtype.Text        `json:"senses"`
	Languages       pgtype.Text        `json:"languages"`
	ChallengeRating pgtype.Text        `json:"challenge_rating"`
	Embedding       pgvector.Vector    `json:"embedding"`
	RawData         []byte             `json:"raw_data"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	Distance        interface{}        `json:"distance"`
}

func (q *Queries) SearchBeastsByEmbedding(ctx context.Context, arg SearchBeastsByEmbeddingParams) ([]SearchBeastsByEmbeddingRow, error) {
	rows, err := q.db.Query(ctx, searchBeastsByEmbedding, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchBeastsByEmbeddingRow{}
	for rows.Next() {
		var i SearchBeastsByEmbeddingRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Size,
			&i.Type,
			&i.Subtype,
			&i.Alignment,
			&i.ArmorClass,
			&i.HitPoints,
			&i.HitDice,
			&i.Speed,
			&i.Abilities,
			&i.Skills,
			&i.Senses,
			&i.Languages,
			&i.ChallengeRating,
			&i.Embedding,
			&i.RawData,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Distance,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBeastEmbedding = `-- name: UpdateBeastEmbedding :exec
UPDATE scry_quest.bestiary 
SET embedding = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateBeastEmbeddingParams struct {
	ID        pgtype.UUID     `json:"id"`
	Embedding pgvector.Vector `json:"embedding"`
}

func (q *Queries) UpdateBeastEmbedding(ctx context.Context, arg UpdateBeastEmbeddingParams) error {
	_, err := q.db.Exec(ctx, updateBeastEmbedding, arg.ID, arg.Embedding)
	return err
}
